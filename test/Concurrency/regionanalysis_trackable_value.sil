// RUN: %target-sil-opt -module-name infer --test-runner %s 2>&1 | %FileCheck %s

// REQUIRES: concurrency
// REQUIRES: asserts

// PLEASE READ THIS!
//
// This test is specifically meant to test how we look through underlying
// objects for region analysis.

sil_stage raw

import Swift
import Builtin
import _Concurrency

////////////////////////
// MARK: Declarations //
////////////////////////

class NonSendableKlass {
}

class SendableKlass : @unchecked Sendable {
}

struct Struct2 {
  let nsLet: NonSendableKlass
  let sLet: SendableKlass
  var nsVar: NonSendableKlass
  var sVar: SendableKlass
}

struct Struct {
  let nsLet: NonSendableKlass
  let sLet: SendableKlass
  var nsVar: NonSendableKlass
  var sVar: SendableKlass

  let struct2Let: Struct2
  var struct2Var: Struct2

  let sStruct: SendableStruct
}

struct SendableStruct : @unchecked Sendable {
  let nsLet: NonSendableKlass
}

class NonSendableKlassWithState {
  let sLet: Struct
  var sVar: Struct
  let recurseLet: NonSendableKlassWithState?
  var recurseVar: NonSendableKlassWithState?
}

sil @transferNonSendableKlass : $@convention(thin) @async (@guaranteed NonSendableKlass) -> ()
sil @useNonSendableKlass : $@convention(thin) (@guaranteed NonSendableKlass) -> ()
sil @constructNonSendableKlass : $@convention(thin) () -> @owned NonSendableKlass
sil @constructStruct : $@convention(thin) () -> @owned Struct
sil @constructSendableStruct : $@convention(thin) () -> @owned SendableStruct

/////////////////
// MARK: Tests //
/////////////////

// CHECK-LABEL: begin running test 1 of 1 on allocbox_direct_access: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var NonSendableKlass }
// CHECK: end running test 1 of 1 on allocbox_direct_access: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_direct_access : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructNonSendableKlass : $@convention(thin) () -> @owned NonSendableKlass
  %c = apply %f() : $@convention(thin) () -> @owned NonSendableKlass
  %a = alloc_box ${ var NonSendableKlass }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*NonSendableKlass

  debug_value [trace] %p

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_nonsendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %nsLet = struct_element_addr %p : $*Struct, #Struct.nsLet
  debug_value [trace] %nsLet

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_nonsendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %nsVar = struct_element_addr %p : $*Struct, #Struct.nsVar
  debug_value [trace] %nsVar

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %6 = struct_element_addr %4 : $*Struct, #Struct.sLet
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_sendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %addr = struct_element_addr %p : $*Struct, #Struct.sLet
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %6 = struct_element_addr %4 : $*Struct, #Struct.sVar
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_sendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %addr = struct_element_addr %p : $*Struct, #Struct.sVar
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_let_grandfield_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_let_grandfield_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_let_grandfield_nonsendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Let
  %nsLet = struct_element_addr %s2 : $*Struct2, #Struct2.nsLet

  debug_value [trace] %nsLet

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_let_grandfield_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_let_grandfield_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_let_grandfield_nonsendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Let
  %nsVar = struct_element_addr %s2 : $*Struct2, #Struct2.nsVar
  debug_value [trace] %nsVar

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_let_grandfield_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %7 = struct_element_addr %6 : $*Struct2, #Struct2.sLet
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_let_grandfield_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_let_grandfield_sendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Let
  %addr = struct_element_addr %s2 : $*Struct2, #Struct2.sLet
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_let_grandfield_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   {{%.*}} = struct_element_addr %6 : $*Struct2, #Struct2.sVar
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_let_grandfield_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_let_grandfield_sendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Let
  %addr = struct_element_addr %s2 : $*Struct2, #Struct2.sVar
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_var_grandfield_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_var_grandfield_nonsendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_var_grandfield_nonsendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Var
  %nsLet = struct_element_addr %s2 : $*Struct2, #Struct2.nsLet

  debug_value [trace] %nsLet

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_var_grandfield_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %2 = alloc_box ${ var Struct }
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_var_grandfield_nonsendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_var_grandfield_nonsendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Var
  %nsVar = struct_element_addr %s2 : $*Struct2, #Struct2.nsVar
  debug_value [trace] %nsVar

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_var_grandfield_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   %7 = struct_element_addr %6 : $*Struct2, #Struct2.sLet
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_var_grandfield_sendable_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_var_grandfield_sendable_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Var
  %addr = struct_element_addr %s2 : $*Struct2, #Struct2.sLet
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_struct_field_var_grandfield_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: yes][region_value_kind: disconnected].
// CHECK:     Rep Value:   {{%.*}} = struct_element_addr %6 : $*Struct2, #Struct2.sVar
// CHECK: end running test 1 of 1 on allocbox_access_struct_field_var_grandfield_sendable_var: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_struct_field_var_grandfield_sendable_var : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructStruct : $@convention(thin) () -> @owned Struct
  %c = apply %f() : $@convention(thin) () -> @owned Struct
  %a = alloc_box ${ var Struct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p : $*Struct

  %s2 = struct_element_addr %p : $*Struct, #Struct.struct2Var
  %addr = struct_element_addr %s2 : $*Struct2, #Struct2.sVar
  debug_value [trace] %addr

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_sendable_struct_field_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %6 = struct_element_addr %4 : $*SendableStruct, #SendableStruct.nsLet
// CHECK: end running test 1 of 1 on allocbox_access_sendable_struct_field_let: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_sendable_struct_field_let : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructSendableStruct : $@convention(thin) () -> @owned SendableStruct
  %c = apply %f() : $@convention(thin) () -> @owned SendableStruct
  %a = alloc_box ${ var SendableStruct }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %c to [init] %p

  %s2 = struct_element_addr %p : $*SendableStruct, #SendableStruct.nsLet
  debug_value [trace] %s2

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on allocbox_access_sendable_struct_field_let_2: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: yes][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %4 = struct_element_addr %2 : $*SendableStruct, #SendableStruct.nsLet
// CHECK: end running test 1 of 1 on allocbox_access_sendable_struct_field_let_2: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @allocbox_access_sendable_struct_field_let_2 : $@convention(thin) () -> () {
bb0:
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %f = function_ref @constructSendableStruct : $@convention(thin) () -> @owned SendableStruct
  %c = apply %f() : $@convention(thin) () -> @owned SendableStruct
  %a = alloc_stack $SendableStruct
  store %c to [init] %a

  %s2 = struct_element_addr %a : $*SendableStruct, #SendableStruct.nsLet
  debug_value [trace] %s2

  destroy_addr %a
  dealloc_stack %a
  %9999 = tuple ()
  return %9999 : $()
}

// CHECK-LABEL: begin running test 1 of 1 on class_lookthrough_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:     Rep Value:   %6 = ref_element_addr %5 : $NonSendableKlassWithState, #NonSendableKlassWithState.sLet
// CHECK: end running test 1 of 1 on class_lookthrough_test: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @class_lookthrough_test : $@convention(thin) (@owned NonSendableKlassWithState) -> () {
bb0(%0 : @owned $NonSendableKlassWithState):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %a = alloc_box ${ var NonSendableKlassWithState }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %0 to [init] %p : $*NonSendableKlassWithState

  %p2 = load_borrow %p
  %s = ref_element_addr %p2 : $NonSendableKlassWithState, #NonSendableKlassWithState.sLet
  debug_value [trace] %s
  end_borrow %p2

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// We model unchecked_enum_data as an assign, so we do not look through it. The
// result of this is that we consider it a separate value (even though we could
// cheat potentially).
//
// CHECK-LABEL: begin running test 1 of 1 on class_lookthrough_test_2: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:   Rep Value:   %8 = unchecked_enum_data %7 : $Optional<NonSendableKlassWithState>, #Optional.some!enumelt
// CHECK: end running test 1 of 1 on class_lookthrough_test_2: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @class_lookthrough_test_2 : $@convention(thin) (@owned NonSendableKlassWithState) -> () {
bb0(%0 : @owned $NonSendableKlassWithState):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %a = alloc_box ${ var NonSendableKlassWithState }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %0 to [init] %p : $*NonSendableKlassWithState

  %p2 = load_borrow %p
  %s = ref_element_addr %p2 : $NonSendableKlassWithState, #NonSendableKlassWithState.recurseLet
  %s2 = load_borrow %s
  %s3 = unchecked_enum_data %s2 : $Optional<NonSendableKlassWithState>, #Optional.some!enumelt
  debug_value [trace] %s3
  end_borrow %s2
  end_borrow %p2

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}

// We always stop at ref_element_addr since it is a base of a value.
//
// CHECK-LABEL: begin running test 1 of 1 on class_lookthrough_test_3: sil_regionanalysis_underlying_tracked_value with: @trace[0]
// CHECK: TrackableValue. State: TrackableValueState[id: 0][is_no_alias: no][is_sendable: no][region_value_kind: disconnected].
// CHECK:   Rep Value:   %9 = ref_element_addr %8 : $NonSendableKlassWithState, #NonSendableKlassWithState.sLet
// CHECK: end running test 1 of 1 on class_lookthrough_test_3: sil_regionanalysis_underlying_tracked_value with: @trace[0]
sil [ossa] @class_lookthrough_test_3 : $@convention(thin) (@owned NonSendableKlassWithState) -> () {
bb0(%0 : @owned $NonSendableKlassWithState):
  specify_test "sil_regionanalysis_underlying_tracked_value @trace[0]"
  %a = alloc_box ${ var NonSendableKlassWithState }
  %ab = begin_borrow %a
  %p = project_box %ab, 0
  store %0 to [init] %p : $*NonSendableKlassWithState

  %p2 = load_borrow %p
  %s = ref_element_addr %p2 : $NonSendableKlassWithState, #NonSendableKlassWithState.recurseLet
  %s2 = load_borrow %s
  %s3 = unchecked_enum_data %s2 : $Optional<NonSendableKlassWithState>, #Optional.some!enumelt
  %s4 = ref_element_addr %s3 : $NonSendableKlassWithState, #NonSendableKlassWithState.sLet
  debug_value [trace] %s4
  end_borrow %s2
  end_borrow %p2

  end_borrow %ab
  destroy_value %a
  %9999 = tuple ()
  return %9999 : $()
}
